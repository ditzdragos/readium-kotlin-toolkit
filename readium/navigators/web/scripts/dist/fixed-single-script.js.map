{"version":3,"file":"fixed-single-script.js","mappings":"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","sources":["webpack://readium-js/./src/fixed/page-manager.ts","webpack://readium-js/./src/util/viewport.ts","webpack://readium-js/./src/common/gestures.ts","webpack://readium-js/./src/fixed/single-area-manager.ts","webpack://readium-js/./src/util/fit.ts","webpack://readium-js/./src/bridge/fixed-gestures-bridge.ts","webpack://readium-js/./src/index-fixed-single.ts","webpack://readium-js/./src/bridge/fixed-single-bridge.ts"],"sourcesContent":["/** Manages a fixed layout resource embedded in an iframe. */\nexport class PageManager {\n    constructor(window, iframe, listener) {\n        this.margins = { top: 0, right: 0, bottom: 0, left: 0 };\n        this.channel = new MessageChannel();\n        if (!iframe.contentWindow) {\n            throw Error(\"Iframe argument must have been attached to DOM.\");\n        }\n        this.listener = listener;\n        this.iframe = iframe;\n        this.iframe.addEventListener(\"load\", () => {\n            this.onIframeLoaded();\n        });\n    }\n    show() {\n        this.iframe.style.display = \"unset\";\n    }\n    hide() {\n        this.iframe.style.display = \"none\";\n    }\n    /** Sets page margins. */\n    setMargins(margins) {\n        if (this.margins == margins) {\n            return;\n        }\n        this.iframe.style.marginTop = this.margins.top + \"px\";\n        this.iframe.style.marginLeft = this.margins.left + \"px\";\n        this.iframe.style.marginBottom = this.margins.bottom + \"px\";\n        this.iframe.style.marginRight = this.margins.right + \"px\";\n    }\n    /** Loads page content. */\n    loadPage(url) {\n        this.iframe.src = url;\n    }\n    /** Sets the size of this page without content. */\n    setPlaceholder(size) {\n        this.iframe.style.width = size.width + \"px\";\n        this.iframe.style.height = size.height + \"px\";\n        this.size = size;\n    }\n    onIframeLoaded() {\n        const viewport = this.iframe.contentWindow.document.querySelector(\"meta[name=viewport]\");\n        if (!viewport || viewport instanceof HTMLMetaElement) {\n            //FIXME: handle edge case\n            return;\n        }\n        const pageSize = this.parsePageSize(viewport);\n        if (!pageSize) {\n            //FIXME: handle edge case\n            return;\n        }\n        this.iframe.style.width = pageSize.width + \"px\";\n        this.iframe.style.height = pageSize.height + \"px\";\n        this.size = pageSize;\n        this.channel.port1.onmessage = (message) => {\n            console.log(`onmessage ${message}`);\n            this.onMessageFromIframe(message);\n        };\n        this.iframe.contentWindow.postMessage(\"Init\", \"*\", [this.channel.port2]);\n        this.listener.onIframeLoaded();\n    }\n    onMessageFromIframe(message) {\n        if (message.data.x && message.data.y) {\n            this.listener.onTap({ x: message.data.x, y: message.data.y });\n        }\n    }\n    /** Parses the page size from the viewport meta tag of the loaded resource. */\n    parsePageSize(viewportMeta) {\n        const regex = /(\\w+) *= *([^\\s,]+)/g;\n        const properties = new Map();\n        let match;\n        while ((match = regex.exec(viewportMeta.content))) {\n            if (match != null) {\n                properties.set(match[1], match[2]);\n            }\n        }\n        const width = parseFloat(properties.get(\"width\"));\n        const height = parseFloat(properties.get(\"height\"));\n        if (width && height) {\n            return { width, height };\n        }\n        else {\n            return undefined;\n        }\n    }\n}\n","export class ViewportStringBuilder {\n    setInitialScale(scale) {\n        this.initialScale = scale;\n        return this;\n    }\n    setMinimumScale(scale) {\n        this.minimumScale = scale;\n        return this;\n    }\n    setWidth(width) {\n        this.width = width;\n        return this;\n    }\n    setHeight(height) {\n        this.height = height;\n        return this;\n    }\n    build() {\n        const components = [];\n        if (this.initialScale) {\n            components.push(\"initial-scale=\" + this.initialScale);\n        }\n        if (this.minimumScale) {\n            components.push(\"minimum-scale=\" + this.minimumScale);\n        }\n        if (this.width) {\n            components.push(\"width=\" + this.width);\n        }\n        if (this.height) {\n            components.push(\"height=\" + this.height);\n        }\n        return components.join(\", \");\n    }\n}\n","export class GesturesDetector {\n    constructor(window, listener) {\n        console.log(`Constructing Gesturesdetector for window ${window}`);\n        this.window = window;\n        this.listener = listener;\n        document.addEventListener(\"click\", (event) => {\n            console.log(\"onClick\");\n            this.onClick(event);\n        }, false);\n        /*document.addEventListener(\"DOMContentLoaded\", () => {\n          console.log(\"DOM content loaded\")\n        })*/\n    }\n    onClick(event) {\n        if (event.defaultPrevented) {\n            return;\n        }\n        const selection = this.window.getSelection();\n        if (selection && selection.type == \"Range\") {\n            // There's an on-going selection, the tap will dismiss it so we don't forward it.\n            // selection.type might be None (collapsed) or Caret with a collapsed range\n            // when there is not true selection.\n            return;\n        }\n        if (event.target instanceof Element &&\n            this.nearestInteractiveElement(event.target)) {\n            return;\n        }\n        console.log(\"tap detected\");\n        this.listener.onTap(event);\n        event.stopPropagation();\n        event.preventDefault();\n    }\n    // See. https://github.com/JayPanoz/architecture/tree/touch-handling/misc/touch-handling\n    nearestInteractiveElement(element) {\n        if (element == null) {\n            return null;\n        }\n        const interactiveTags = [\n            \"a\",\n            \"audio\",\n            \"button\",\n            \"canvas\",\n            \"details\",\n            \"input\",\n            \"label\",\n            \"option\",\n            \"select\",\n            \"submit\",\n            \"textarea\",\n            \"video\",\n        ];\n        if (interactiveTags.indexOf(element.nodeName.toLowerCase()) != -1) {\n            return element.outerHTML;\n        }\n        // Checks whether the element is editable by the user.\n        if (element.hasAttribute(\"contenteditable\") &&\n            element.getAttribute(\"contenteditable\").toLowerCase() != \"false\") {\n            return element.outerHTML;\n        }\n        // Checks parents recursively because the touch might be for example on an <em> inside a <a>.\n        if (element.parentElement) {\n            return this.nearestInteractiveElement(element.parentElement);\n        }\n        return null;\n    }\n}\n","import { computeScale } from \"../util/fit\";\nimport { PageManager } from \"./page-manager\";\nimport { ViewportStringBuilder } from \"../util/viewport\";\nimport { GesturesDetector } from \"../common/gestures\";\nexport class SingleAreaManager {\n    constructor(window, iframe, metaViewport, listener) {\n        this.fit = \"contain\" /* Fit.Contain */;\n        this.insets = { top: 0, right: 0, bottom: 0, left: 0 };\n        this.scale = 1;\n        const wrapperGesturesListener = {\n            onTap: (event) => {\n                var _a, _b, _c;\n                console.log(`metaViewport ${metaViewport.content}`);\n                const docElement = window.document.documentElement;\n                console.log(`docElement ${docElement.scrollLeft} ${docElement.scrollTop}`);\n                console.log(`scale ${(_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.scale}`);\n                console.log(`visualviewport ${(_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.width} ${(_c = window.visualViewport) === null || _c === void 0 ? void 0 : _c.height}`);\n                const tapEvent = {\n                    x: (event.clientX * this.scale) /\n                        (window.visualViewport.scale * this.scale),\n                    y: (event.clientY * this.scale) /\n                        (window.visualViewport.scale * this.scale),\n                };\n                listener.onTap(tapEvent);\n            },\n        };\n        new GesturesDetector(window, wrapperGesturesListener);\n        this.metaViewport = metaViewport;\n        const pageListener = {\n            onIframeLoaded: () => {\n                this.onIframeLoaded();\n            },\n            onTap: (event) => {\n                var _a, _b, _c;\n                const docElement = window.document.documentElement;\n                console.log(`docElement ${docElement.scrollLeft} ${docElement.scrollTop}`);\n                console.log(`scale ${(_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.scale}`);\n                console.log(`visualviewport ${(_b = window.visualViewport) === null || _b === void 0 ? void 0 : _b.width} ${(_c = window.visualViewport) === null || _c === void 0 ? void 0 : _c.height}`);\n                const boundingRect = iframe.getBoundingClientRect();\n                console.log(`boundingRect $} ${boundingRect.left} ${boundingRect.top}`);\n                const tapEvent = {\n                    x: ((event.x + boundingRect.left) * this.scale) /\n                        (window.visualViewport.scale * this.scale),\n                    y: ((event.y + boundingRect.top) * this.scale) /\n                        (window.visualViewport.scale * this.scale),\n                };\n                listener.onTap(tapEvent);\n            },\n        };\n        this.page = new PageManager(window, iframe, pageListener);\n    }\n    setViewport(viewport, insets) {\n        if (this.viewport == viewport && this.insets == insets) {\n            return;\n        }\n        this.viewport = viewport;\n        this.insets = insets;\n        this.layout();\n    }\n    setFit(fit) {\n        if (this.fit == fit) {\n            return;\n        }\n        this.fit = fit;\n        this.layout();\n    }\n    loadResource(url) {\n        this.page.hide();\n        this.page.loadPage(url);\n    }\n    onIframeLoaded() {\n        if (!this.page.size) {\n            // FIXME: raise error\n        }\n        else {\n            this.layout();\n        }\n    }\n    layout() {\n        if (!this.page.size || !this.viewport) {\n            return;\n        }\n        const margins = {\n            top: this.insets.top,\n            right: this.insets.right,\n            bottom: this.insets.bottom,\n            left: this.insets.left,\n        };\n        this.page.setMargins(margins);\n        const safeDrawingSize = {\n            width: this.viewport.width - this.insets.left - this.insets.right,\n            height: this.viewport.height - this.insets.top - this.insets.bottom,\n        };\n        const scale = computeScale(this.fit, this.page.size, safeDrawingSize);\n        this.metaViewport.content = new ViewportStringBuilder()\n            .setInitialScale(scale)\n            .setMinimumScale(scale)\n            .setWidth(this.page.size.width)\n            .setHeight(this.page.size.height)\n            .build();\n        this.scale = scale;\n        this.page.show();\n    }\n}\n","export function computeScale(fit, content, container) {\n    switch (fit) {\n        case \"contain\" /* Fit.Contain */:\n            return fitContain(content, container);\n        case \"width\" /* Fit.Width */:\n            return fitWidth(content, container);\n        case \"height\" /* Fit.Height */:\n            return fitHeight(content, container);\n    }\n}\nfunction fitContain(content, container) {\n    const widthRatio = container.width / content.width;\n    const heightRatio = container.height / content.height;\n    return Math.min(widthRatio, heightRatio);\n}\nfunction fitWidth(content, container) {\n    return container.width / content.width;\n}\nfunction fitHeight(content, container) {\n    return container.height / content.height;\n}\n","export class BridgeGesturesAdapter {\n    constructor(gesturesApi) {\n        this.nativeApi = gesturesApi;\n    }\n    onTap(event) {\n        this.nativeApi.onTap(JSON.stringify(event));\n    }\n}\n","//\n//  Copyright 2024 Readium Foundation. All rights reserved.\n//  Use of this source code is governed by the BSD-style license\n//  available in the top-level LICENSE file of the project.\n//\nimport { FixedSingleBridge } from \"./bridge/fixed-single-bridge\";\nconst iframe = document.getElementById(\"page\");\nconst metaViewport = document.querySelector(\"meta[name=viewport]\");\nwindow.singleArea = new FixedSingleBridge(window, iframe, metaViewport, window.gestures);\n","import { SingleAreaManager } from \"../fixed/single-area-manager\";\nimport { BridgeGesturesAdapter } from \"./fixed-gestures-bridge\";\nexport class FixedSingleBridge {\n    constructor(window, iframe, metaViewport, gestures) {\n        const listener = new BridgeGesturesAdapter(gestures);\n        this.manager = new SingleAreaManager(window, iframe, metaViewport, listener);\n    }\n    loadResource(url) {\n        this.manager.loadResource(url);\n    }\n    setViewport(viewporttWidth, viewportHeight, insetTop, insetRight, insetBottom, insetLeft) {\n        const viewport = { width: viewporttWidth, height: viewportHeight };\n        const insets = {\n            top: insetTop,\n            left: insetLeft,\n            bottom: insetBottom,\n            right: insetRight,\n        };\n        this.manager.setViewport(viewport, insets);\n    }\n    setFit(fit) {\n        if (fit != \"contain\" && fit != \"width\" && fit != \"height\") {\n            throw Error(`Invalid fit value: ${fit}`);\n        }\n        this.manager.setFit(fit);\n    }\n}\n"],"names":["PageManager","constructor","window","iframe","listener","this","margins","top","right","bottom","left","channel","MessageChannel","contentWindow","Error","addEventListener","onIframeLoaded","show","style","display","hide","setMargins","marginTop","marginLeft","marginBottom","marginRight","loadPage","url","src","setPlaceholder","size","width","height","viewport","document","querySelector","HTMLMetaElement","pageSize","parsePageSize","port1","onmessage","message","console","log","onMessageFromIframe","postMessage","port2","data","x","y","onTap","viewportMeta","regex","properties","Map","match","exec","content","set","parseFloat","get","ViewportStringBuilder","setInitialScale","scale","initialScale","setMinimumScale","minimumScale","setWidth","setHeight","build","components","push","join","GesturesDetector","event","onClick","defaultPrevented","selection","getSelection","type","target","Element","nearestInteractiveElement","stopPropagation","preventDefault","element","indexOf","nodeName","toLowerCase","hasAttribute","getAttribute","outerHTML","parentElement","SingleAreaManager","metaViewport","fit","insets","_a","_b","_c","docElement","documentElement","scrollLeft","scrollTop","visualViewport","tapEvent","clientX","clientY","pageListener","boundingRect","getBoundingClientRect","page","setViewport","layout","setFit","loadResource","safeDrawingSize","container","widthRatio","heightRatio","Math","min","fitContain","fitWidth","fitHeight","computeScale","BridgeGesturesAdapter","gesturesApi","nativeApi","JSON","stringify","getElementById","singleArea","gestures","manager","viewporttWidth","viewportHeight","insetTop","insetRight","insetBottom","insetLeft"],"sourceRoot":""}